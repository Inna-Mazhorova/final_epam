exec("""\nimport sys\nimport traceback\n\n\ndef blocking_function(func, importing_module=None):\n    def inner(*args, **kwargs):\n        usage_counter = 0\n        stack = traceback.extract_stack()\n        for line in stack:\n            if line[0] == '<string>':\n                usage_counter += 1\n        try:\n            if not importing_module:\n                blocked_function = inner.__name__\n                if usage_counter == len(stack):\n                    raise PermissionError(f"{blocked_function} function is prohibited to use")\n\n            blocked_import = args[0]\n            if usage_counter == len(stack) and blocked_import == importing_module:\n                raise PermissionError(f"{blocked_import} module is prohibited to use")\n\n        except PermissionError as message:\n            print(message)\n            sys.exit()\n\n        return func(*args, **kwargs)\n\n    inner.__name__ = func.__name__\n    return inner\n\n\nfor blocked_import in sys.argv[1].split(','):\n    __builtins__.__dict__['__import__'] = blocking_function(__builtins__.__dict__['__import__'], blocked_import)\nfor blocked_function in sys.argv[2].split(','):\n    __builtins__.__dict__[blocked_function] = blocking_function(__builtins__.__dict__[blocked_function])\n\ndel blocking_function\n""")
